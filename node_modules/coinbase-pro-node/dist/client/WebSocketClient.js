"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const reconnecting_websocket_1 = __importDefault(require("reconnecting-websocket"));
const ws_1 = __importDefault(require("ws"));
var WebSocketChannelName;
(function (WebSocketChannelName) {
    WebSocketChannelName["FULL"] = "full";
    WebSocketChannelName["HEARTBEAT"] = "heartbeat";
    WebSocketChannelName["LEVEL2"] = "level2";
    WebSocketChannelName["MATCHES"] = "matches";
    WebSocketChannelName["STATUS"] = "status";
    WebSocketChannelName["TICKER"] = "ticker";
    WebSocketChannelName["USER"] = "user";
})(WebSocketChannelName = exports.WebSocketChannelName || (exports.WebSocketChannelName = {}));
var WebSocketRequestType;
(function (WebSocketRequestType) {
    WebSocketRequestType["SUBSCRIBE"] = "subscribe";
    WebSocketRequestType["UNSUBSCRIBE"] = "unsubscribe";
})(WebSocketRequestType = exports.WebSocketRequestType || (exports.WebSocketRequestType = {}));
var WebSocketResponseType;
(function (WebSocketResponseType) {
    WebSocketResponseType["ERROR"] = "error";
    WebSocketResponseType["SUBSCRIPTIONS"] = "subscriptions";
    WebSocketResponseType["HEARTBEAT"] = "heartbeat";
    WebSocketResponseType["STATUS"] = "status";
    WebSocketResponseType["TICKER"] = "ticker";
    WebSocketResponseType["LEVEL2_SNAPSHOT"] = "snapshot";
    WebSocketResponseType["LEVEL2_UPDATE"] = "l2update";
    WebSocketResponseType["FULL_RECEIVED"] = "received";
    WebSocketResponseType["FULL_OPEN"] = "open";
    WebSocketResponseType["FULL_DONE"] = "done";
    WebSocketResponseType["FULL_MATCH"] = "match";
    WebSocketResponseType["FULL_CHANGE"] = "change";
    WebSocketResponseType["FULL_ACTIVATE"] = "activate";
})(WebSocketResponseType = exports.WebSocketResponseType || (exports.WebSocketResponseType = {}));
var WebSocketEvent;
(function (WebSocketEvent) {
    WebSocketEvent["ON_CLOSE"] = "WebSocketEvent.ON_CLOSE";
    WebSocketEvent["ON_ERROR"] = "WebSocketEvent.ON_ERROR";
    WebSocketEvent["ON_MESSAGE"] = "WebSocketEvent.ON_MESSAGE";
    WebSocketEvent["ON_MESSAGE_MATCHES"] = "WebSocketEvent.ON_MESSAGE_MATCHES";
    WebSocketEvent["ON_MESSAGE_TICKER"] = "WebSocketEvent.ON_MESSAGE_TICKER";
    WebSocketEvent["ON_OPEN"] = "WebSocketEvent.ON_OPEN";
})(WebSocketEvent = exports.WebSocketEvent || (exports.WebSocketEvent = {}));
class WebSocketClient extends events_1.EventEmitter {
    constructor(baseURL) {
        super();
        this.baseURL = baseURL;
    }
    connect() {
        return new Promise(resolve => {
            const options = {
                WebSocket: ws_1.default,
                connectionTimeout: 4000,
                debug: false,
                maxReconnectionDelay: 10000,
                maxRetries: Infinity,
                minReconnectionDelay: 4000,
                reconnectionDelayGrowFactor: 1.3,
            };
            this.socket = new reconnecting_websocket_1.default(this.baseURL, [], options);
            this.socket.onclose = (event) => {
                this.emit(WebSocketEvent.ON_CLOSE, event);
            };
            this.socket.onmessage = (event) => {
                const response = JSON.parse(event.data);
                switch (response.type) {
                    case WebSocketResponseType.TICKER:
                        this.emit(WebSocketEvent.ON_MESSAGE_TICKER, response);
                        break;
                    case WebSocketResponseType.FULL_MATCH:
                        this.emit(WebSocketEvent.ON_MESSAGE_MATCHES, response);
                        break;
                    default:
                        this.emit(WebSocketEvent.ON_MESSAGE, response);
                }
            };
            this.socket.onopen = () => {
                this.emit(WebSocketEvent.ON_OPEN);
                resolve(this.socket);
            };
        });
    }
    disconnect(reason = 'Unknown reason') {
        if (this.socket) {
            this.socket.close(WebSocketClient.CLOSE_EVENT_CODE.NORMAL_CLOSURE, reason);
        }
    }
    sendMessage(message, signature) {
        if (!this.socket) {
            throw new Error('You need to connect to the WebSocket first!');
        }
        if (signature) {
            Object.assign(message, signature);
        }
        this.socket.send(JSON.stringify(message));
    }
    subscribe(channel) {
        this.sendMessage({
            channels: [channel],
            product_ids: channel.product_ids,
            type: WebSocketRequestType.SUBSCRIBE,
        });
    }
    unsubscribe(channel) {
        this.sendMessage({
            channels: [channel],
            product_ids: channel.product_ids,
            type: WebSocketRequestType.UNSUBSCRIBE,
        });
    }
}
exports.WebSocketClient = WebSocketClient;
WebSocketClient.CLOSE_EVENT_CODE = {
    GOING_AWAY: 1001,
    NORMAL_CLOSURE: 1000,
    PROTOCOL_ERROR: 1002,
    UNSUPPORTED_DATA: 1003,
};
//# sourceMappingURL=WebSocketClient.js.map